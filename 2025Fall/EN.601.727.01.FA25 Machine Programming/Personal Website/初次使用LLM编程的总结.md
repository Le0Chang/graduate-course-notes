# 首次使用LLM编程的实践心得体会：以“需求主导者”角色用LLM构建个人简历网站
虽然学期刚开始，以及Machine Programming的课程还没讲到使用LLM编程，但我在本科阶段就已经开始尝试使用LLM辅助我编程了。早期的方法特别原始--我将自己写完的充满bug的代码复制粘贴到LLM的交流框并要求LLM修改bug，然而这往往是徒劳，因为bug永远都存在。但是这一次，我以“需求提出者”而非“代码编写者”的身份，全程通过大语言模型（豆包）完成了个人简历网站的开发，从初期需求定义到最终部署上线，我第一次体会到用LLM处理代码任务的核心逻辑--从手动实现代码转向精准定义需求、拆解问题、迭代优化代码，以下是我的具体实践心得：

## 实践背景：从写代码到定需求的角色转变
Machine Programming课程的核心是让LLM成为我们代码工作的协作工具，而我的实践场景是构建个人简历网站。不同于传统编程中查找语法、打标签、反复测试的模式，我全程未参与一行HTML/CSS/JS代码的编写，而是像项目老板一样，围绕个人信息展示的核心目标，逐步向模型传递具体需求：

1. 初始需求：明确网站需包含个人简介（JHU AMS 在读、优化与机器学习方向）、教育经历（本科统计实验班、硕士 AMS）、技能（编程/操作系统/机器学习）” 三大核心模块；

2. 迭代需求：针对每部分提出细化要求（如 “精简About部分，只保留核心信息”，“Experience部分让B.S.和M.S.内容框右对齐”，“时间轴需让轴线穿过圆形中心”，“美化卡片hover效果”等）；

3. 落地需求：解决部署环节的问题（如 “GitHub Pages 404错误排查”，“仓库命名规范”等）。

在这种模式下，我无需关注诸如如何用Tailwind实现时间轴动画，如何写响应式布局代码等细碎的问题，而是可以聚焦于类似于我需要网站呈现什么效果、满足什么功能的方向性问题。大语言模型则扮演了代码实现、语法纠错、样式适配的执行角色，很贴合我暂时对于Machine Programming课程的理念。值得一提的是，该代码的GitHub部署步骤中遇到的问题（如404页面错误、仓库配置异常等），同样是通过向大语言模型提出排查需求、获取解决方案来完成的，这进一步体现了大语言模型在全流程开发中的协作价值。

## 核心心得：精准需求是大语言模型高效协作的前提
在实践中我发现，大语言模型的代码输出质量，完全取决于我提出的需求的清晰度与颗粒度--初期因需求模糊踩过的坑，反而成了最关键的收获：

1. 命令需要拆解到可执行的步骤，避免模糊表述
最初我只下达美化Experience部分的命令，模型输出的效果偏笼统，且会出现一些多余的内容；后来将命令调整为让B.S.和M.S.模块右对齐、时间轴轴线穿过圆形中心、添加卡片hover阴影动画等具体指令，模型立刻能精准匹配视觉要求。这让我意识到：Machine Programming中，拆解需求是核心能力之一。大语言模型无法猜透模糊需求，必须将抽象目标拆成可量化、可描述的具体指令，才能让代码输出贴合预期。有趣的是，豆包模型在这一部分提供一定的可视化便利--它允许你在代码可视化部分直接对可视化内容提出修改要求，这大大改善了指令表达模糊的问题

2. 命令需要伴随上下文内容，减少模型误判
比如在调整教育经历模块时，我最初只说：“精简内容”，结果模型误删了关键信息；后来补充了“保留‘JHU AMS 硕士’，‘山大学士（数据科学与AI实验班）’，去掉多余描述”，模型才精准执行。这说明LLM缺乏对个人场景的默认认知，需求中必须包含明确的上下文边界（比如需要保留哪些核心信息、删除哪些冗余内容），尤其是涉及个人信息、专业术语（如“AMS”“优化与机器学习方向”）时，需明确声明，避免模型因信息不全导致输出偏差。

3. 命令需要允许迭代，接受逐步优化的过程
在网站开发中，我经历了多次需求调整-模型修改的循环：比如先让时间轴右对齐，再要求美化圆形标记，最后补充滚动时渐入动画；部署阶段从按步骤上传代码到排查404错误，也是通过发现问题-补充需求的模式进行的（如‘检查GitHub仓库命名是否符合xxx规范’，‘确认GitHub Pages是否开启’等）。这让我明白了Machine Programming并非一次需求就能完美落地，而是需求-输出-反馈-优化的闭环。作为需求主导者，我需要有迭代思维—— 先明确核心功能，再逐步细化细节，遇到问题时不是否定模型，而是通过补充需求引导模型修正，这比一次性提出完美需求更符合实际开发逻辑。

## 对Machine Programming课程的新认知：大语言模型是协作工具（员工），人的核心是问题定位与需求把控（老板）
此次实践打破了我对编程的传统认知：过去认为会用编程语言写代码才是编程，现在发现，在Machine Programming的场景下，能定义清楚要做什么，要达到什么效果，哪里出了问题比会写代码更重要-- 大语言模型可以替代重复性代码编写，但无法替代对目标的拆解、对问题的定位、对需求的迭代。比如在解决GitHub Pages 404错误时，我不需要懂DNS解析原理，但需要能向模型提出“排查仓库命名是否正确”，“确认GitHub Pages来源分支是否为main”等定向需求，模型则会基于这些需求提供具体解决方案；这种人定位问题方向、模型提供技术方案的协作模式，正是Machine Programming课程强调的人机协同核心--大语言模型是代码执行层的工具，人是需求决策层的主导者。

## 总结：Machine Programming的本质是用需求驱动技术落地
此次用大语言模型构建网站的实践，让我深刻理解：Machine Programming并非是让模型替代人编程，而是让人从繁琐的代码实现中解放出来，聚焦更高维度的需求设计与问题解决。作为自发地课程实践，它不仅锻炼了我精准表达需求、拆解问题的能力，更让我意识到未来面对复杂代码任务时，明确目标、定义边界、迭代优化的思维，比掌握某一种语法更具长期价值--毕竟代码可以由模型生成，但知道要做什么、怎么做”的核心逻辑，永远需要人来主导。
